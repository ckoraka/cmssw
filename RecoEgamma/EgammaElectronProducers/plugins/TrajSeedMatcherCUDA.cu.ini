#include <cuda_runtime.h>
#include <stdio.h>
#include <iostream>


namespace {
  auto makeMatchingCuts(std::vector<edm::ParameterSet> const& cutsPSets) {
    std::vector<std::unique_ptr<TrajSeedMatcher::MatchingCuts> > matchingCuts;

    for (const auto& cutPSet : cutsPSets) {
      int version = cutPSet.getParameter<int>("version");
      switch (version) {
        case 1:
          matchingCuts.emplace_back(std::make_unique<TrajSeedMatcher::MatchingCutsV1>(cutPSet));
          break;
        case 2:
          matchingCuts.emplace_back(std::make_unique<TrajSeedMatcher::MatchingCutsV2>(cutPSet));
          break;
        default:
          throw cms::Exception("InvalidConfig") << " Error TrajSeedMatcher::TrajSeedMatcher pixel match cuts version "
                                                << version << " not recognised" << std::endl;
      }
    }

    return matchingCuts;
  }

  TrajSeedMatcher::SCHitMatch makeSCHitMatch(const GlobalPoint& vtxPos,
                                             const TrajectoryStateOnSurface& trajState,
                                             const TrackingRecHit& hit,
                                             float et,
                                             float eta,
                                             float phi,
                                             int charge,
                                             int nrClus) {
    EleRelPointPair pointPair(hit.globalPosition(), trajState.globalParameters().position(), vtxPos);
    float dRZ = hit.geographicalId().subdetId() == PixelSubdetector::PixelBarrel ? pointPair.dZ() : pointPair.dPerp();
    return {hit.geographicalId(), hit.globalPosition(), dRZ, pointPair.dPhi(), hit, et, eta, phi, charge, nrClus};
  }

  const std::vector<TrajSeedMatcher::MatchInfo> makeMatchInfoVector(
      std::vector<TrajSeedMatcher::SCHitMatch> const& posCharge,
      std::vector<TrajSeedMatcher::SCHitMatch> const& negCharge) {
    std::vector<TrajSeedMatcher::MatchInfo> matchInfos;
    size_t nrHitsMax = std::max(posCharge.size(), negCharge.size());
    for (size_t hitNr = 0; hitNr < nrHitsMax; hitNr++) {
      DetId detIdPos = hitNr < posCharge.size() ? posCharge[hitNr].detId : DetId(0);
      float dRZPos = hitNr < posCharge.size() ? posCharge[hitNr].dRZ : std::numeric_limits<float>::max();
      float dPhiPos = hitNr < posCharge.size() ? posCharge[hitNr].dPhi : std::numeric_limits<float>::max();

      DetId detIdNeg = hitNr < negCharge.size() ? negCharge[hitNr].detId : DetId(0);
      float dRZNeg = hitNr < negCharge.size() ? negCharge[hitNr].dRZ : std::numeric_limits<float>::max();
      float dPhiNeg = hitNr < negCharge.size() ? negCharge[hitNr].dPhi : std::numeric_limits<float>::max();

      if (detIdPos != detIdNeg && (detIdPos.rawId() != 0 && detIdNeg.rawId() != 0)) {
        cms::Exception("LogicError") << " error in " << __FILE__ << ", " << __LINE__
                                     << " hits to be combined have different detIDs, this should not be possible and "
                                        "nothing good will come of it";
      }
      DetId detId = detIdPos.rawId() != 0 ? detIdPos : detIdNeg;
      matchInfos.push_back({detId, dRZPos, dRZNeg, dPhiPos, dPhiNeg});
    }
    return matchInfos;
  }
};  // namespace

TrajSeedMatcher::Configuration::Configuration(const edm::ParameterSet& pset, edm::ConsumesCollector&& cc)
    : magFieldToken{cc.esConsumes()},
      paramMagFieldToken{cc.esConsumes(pset.getParameter<edm::ESInputTag>("paramMagField"))},
      navSchoolToken{cc.esConsumes(pset.getParameter<edm::ESInputTag>("navSchool"))},
      detLayerGeomToken{cc.esConsumes(pset.getParameter<edm::ESInputTag>("detLayerGeom"))},
      useRecoVertex{pset.getParameter<bool>("useRecoVertex")},
      enableHitSkipping{pset.getParameter<bool>("enableHitSkipping")},
      requireExactMatchCount{pset.getParameter<bool>("requireExactMatchCount")},
      useParamMagFieldIfDefined{pset.getParameter<bool>("useParamMagFieldIfDefined")},
      minNrHits{pset.getParameter<std::vector<unsigned int> >("minNrHits")},
      minNrHitsValidLayerBins{pset.getParameter<std::vector<int> >("minNrHitsValidLayerBins")},
      matchingCuts{makeMatchingCuts(pset.getParameter<std::vector<edm::ParameterSet> >("matchingCuts"))} {
  if (minNrHitsValidLayerBins.size() + 1 != minNrHits.size()) {
    throw cms::Exception("InvalidConfig")
        << " TrajSeedMatcher::TrajSeedMatcher minNrHitsValidLayerBins should be 1 less than minNrHits when its "
        << minNrHitsValidLayerBins.size() << " vs " << minNrHits.size();
  }
}

TrajSeedMatcher::TrajSeedMatcher(TrajectorySeedCollection const& seeds,
                                 math::XYZPoint const& vprim,
                                 TrajSeedMatcher::Configuration const& cfg,
                                 edm::EventSetup const& iSetup,
                                 MeasurementTrackerEvent const& measTkEvt)
    : seeds_{seeds},
      vprim_(vprim.x(), vprim.y(), vprim.z()),
      cfg_{cfg},
      magField_{iSetup.getData(cfg_.magFieldToken)},
      magFieldParam_{iSetup.getData(cfg_.paramMagFieldToken)},
      measTkEvt_{measTkEvt},
      navSchool_{iSetup.getData(cfg_.navSchoolToken)},
      detLayerGeom_{iSetup.getData(cfg_.detLayerGeomToken)},
      forwardPropagator_(alongMomentum, kElectronMass_, &magField_),
      backwardPropagator_(oppositeToMomentum, kElectronMass_, &magField_) {}

edm::ParameterSetDescription TrajSeedMatcher::makePSetDescription() {
  edm::ParameterSetDescription desc;
  desc.add<bool>("useRecoVertex", false);
  desc.add<bool>("enableHitSkipping", false);
  desc.add<bool>("requireExactMatchCount", true);
  desc.add<bool>("useParamMagFieldIfDefined", true);
  desc.add<edm::ESInputTag>("paramMagField", edm::ESInputTag{"", "ParabolicMf"});
  desc.add<edm::ESInputTag>("navSchool", edm::ESInputTag{"", "SimpleNavigationSchool"});
  desc.add<edm::ESInputTag>("detLayerGeom", edm::ESInputTag{"", "hltESPGlobalDetLayerGeometry"});
  desc.add<std::vector<int> >("minNrHitsValidLayerBins", {4});
  desc.add<std::vector<unsigned int> >("minNrHits", {2, 3});

  edm::ParameterSetDescription cutsDesc;
  auto cutDescCases = 1 >> (edm::ParameterDescription<double>("dPhiMax", 0.04, true) and
                            edm::ParameterDescription<double>("dRZMax", 0.09, true) and
                            edm::ParameterDescription<double>("dRZMaxLowEtThres", 20., true) and
                            edm::ParameterDescription<std::vector<double> >("dRZMaxLowEtEtaBins", {1., 1.5}, true) and
                            edm::ParameterDescription<std::vector<double> >("dRZMaxLowEt", {0.09, 0.15, 0.09}, true)) or
                      2 >> (edm::ParameterDescription<std::vector<double> >("dPhiMaxHighEt", {0.003}, true) and
                            edm::ParameterDescription<std::vector<double> >("dPhiMaxHighEtThres", {0.0}, true) and
                            edm::ParameterDescription<std::vector<double> >("dPhiMaxLowEtGrad", {0.0}, true) and
                            edm::ParameterDescription<std::vector<double> >("dRZMaxHighEt", {0.005}, true) and
                            edm::ParameterDescription<std::vector<double> >("dRZMaxHighEtThres", {30}, true) and
                            edm::ParameterDescription<std::vector<double> >("dRZMaxLowEtGrad", {-0.002}, true) and
                            edm::ParameterDescription<std::vector<double> >("etaBins", {}, true));
  cutsDesc.ifValue(edm::ParameterDescription<int>("version", 1, true), std::move(cutDescCases));

  edm::ParameterSet defaults;
  defaults.addParameter<double>("dPhiMax", 0.04);
  defaults.addParameter<double>("dRZMax", 0.09);
  defaults.addParameter<double>("dRZMaxLowEtThres", 0.09);
  defaults.addParameter<std::vector<double> >("dRZMaxLowEtEtaBins", std::vector<double>{1., 1.5});
  defaults.addParameter<std::vector<double> >("dRZMaxLowEt", std::vector<double>{0.09, 0.09, 0.09});
  defaults.addParameter<int>("version", 1);
  desc.addVPSet("matchingCuts", cutsDesc, std::vector<edm::ParameterSet>{defaults, defaults, defaults});

  return desc;
}

